<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lessons Learned Vibe Coding an iOS App from Scratch - Nauman Mustafa</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="./style.css">
</head>

<body>
    <div class="theme-toggle" id="theme-toggle">
        <i class="fas fa-sun"></i>
        <span>Dark Mode</span>
    </div>

    <div class="paper-container">
        <div class="paper-lines"></div>

        <div class="content-wrapper">
            <a href="../" class="back-link">
                <i class="fas fa-arrow-left"></i>
                <span>Back to Home</span>
            </a>

            <article>
                <blockquote>
                    <strong>Disclaimer</strong>: The main points of this essay were written by a human, edited by an AI,
                    and reviewed by the human once more.
                </blockquote>

                <h1>Lessons Learned Vibe Coding an iOS App from Scratch</h1>

                <p>I've been a developer for over 7 years, primarily focused on Python and Machine Learning. For a long
                    time, I've had the desire to build my own apps, but my lack of experience in frontend and mobile
                    development was a constant source of frustration.</p>

                <p>Everything changed with the recent rise of "vibe-coding." I discovered a newfound ability to build
                    across the entire stack—frontend, backend, and infrastructure—regardless of my prior expertise. In
                    fact, this very website was developed using Cursor and Claude.</p>

                <p>With this new momentum, I decided to take on a challenge: publishing a vibe-coded iOS app from
                    scratch. This blog post is a collection of the lessons I learned along the way, shared so that
                    others can benefit from my journey.</p>

                <h2>The Lessons Learned</h2>

                <h3>1. Choosing the Right Tools: IDEs and Models</h3>

                <p>The first step was deciding on the environment. In vibe-coding, your IDE and LLM are your primary
                    collaborators. I weighed my options between <strong>Claude Code</strong>, <strong>Codex</strong>,
                    and <strong>Cursor</strong>. Although I've since learned more about the others, I stuck with Cursor
                    at the time because of my familiarity with it.</p>

                <p>For the models, I had access to both <strong>Claude Sonnet 4.5</strong> and <strong>GPT-5</strong>. I
                    ended up developing a hybrid strategy based on their strengths:</p>

                <ul>
                    <li><strong>GPT-5-High</strong>: This became my primary workhorse. While it was a bit slower, it was
                        incredibly methodological and precise. It was also more cost-effective, making it ideal for the
                        bulk of the coding tasks.</li>
                    <li><strong>Claude Sonnet 4.5</strong>: Whenever GPT-5 hit a wall or when I needed a quick solution
                        for complex logic, I switched to Sonnet 4.5. It was exceptionally fast and agile, though it came
                        at a higher cost.</li>
                </ul>

                <div class="takeaway">
                    <strong>The takeaway:</strong> You don't have to stick to one model. Use the precise, cost-effective
                    one for the foundation, and bring in the specialized "powerhouse" when you need to solve high-level
                    architectural or logic puzzles.
                </div>

                <h3>2. Framework Selection: The "Native-ish" Sweet Spot</h3>

                <p>Choosing the right framework was critical. I evaluated three main contenders:
                    <strong>SwiftUI</strong>, <strong>React Native</strong>, and <strong>Flutter</strong>.</p>

                <ul>
                    <li><strong>SwiftUI (Xcode)</strong>: Coming from a Python background, Xcode and Swift felt somewhat
                        "alien." It reminded me of the heavy, monolithic IDEs from the Visual Studio era, and since I
                        had never developed for the Apple ecosystem, the learning curve felt unnecessarily steep for a
                        vibe-coding project.</li>
                    <li><strong>React Native</strong>: This felt too much like web development. The massive
                        <code>node_modules</code> folders, the heavy React dependency, and the layers of wrappers didn't
                        appeal to me. I wanted something that felt more focused on the mobile experience itself.</li>
                    <li><strong>Flutter</strong>: This turned out to be the balanced option. It provided a "native-ish"
                        feel without the overhead of React Native or the steep barrier of entry of SwiftUI.</li>
                </ul>

                <div class="takeaway">
                    <strong>The takeaway:</strong> Trust your intuition on the developer experience. Flutter provided
                    the perfect middle ground for someone with a non-mobile background, and this decision paid off
                    significantly as the project progressed.
                </div>

                <h3>3. Solving a Real Problem: The "Not-Just-a-Wrapper" Realization</h3>

                <p>My goal wasn't to build a $1M+ MRR powerhouse; I simply had a specific problem I wanted to solve:
                    <strong>real-time voice translation.</strong></p>

                <p>To achieve this, I chose <strong>OpenAI's GPT-realtime</strong> as the engine. With the right
                    prompting, it works remarkably well. On the surface, the app was essentially a "wrapper" around this
                    API. However, the process of building it taught me a humbling lesson: <strong>creating a truly great
                        user experience around an AI wrapper is far from trivial.</strong></p>

                <p>When you're dealing with real-time audio, latency, and voice interactions, the "wrapper" part is
                    actually the smallest piece of the puzzle. Most of the effort goes into making the interaction feel
                    seamless—handling network interruptions, visual feedback for voice activity, and ensuring the
                    interface doesn't get in the way of the conversation.</p>

                <div class="takeaway">
                    <strong>The takeaway:</strong> Don't underestimate the complexity of the "wrapper." The value isn't
                    just in the API you're calling, but in the polish, reliability, and user experience you build on top
                    of it.
                </div>

                <h3>4. Backend Infrastructure: Staying Lightweight with Cloudflare</h3>

                <p>For the backend, I needed something that matched the speed and efficiency of the "vibe-coding"
                    philosophy. I chose <strong>Cloudflare Workers</strong>, and it turned out to be the best decision
                    for several reasons:</p>

                <ul>
                    <li><strong>Serverless & Scalable</strong>: It's extremely lightweight and handles scaling out of
                        the box.</li>
                    <li><strong>Integrated Ecosystem</strong>: With a built-in database (D1) and KV storage, it felt
                        like an almost complete "all-in-one" solution for serverless development.</li>
                    <li><strong>Email via Resend</strong>: The only missing piece in Cloudflare's core offering
                        (currently in private beta) was email. I bridged this gap by using <strong>Resend</strong>,
                        which was incredibly easy to integrate and maintain.</li>
                </ul>

                <div class="takeaway">
                    <strong>The takeaway:</strong> A serverless, integrated backend allows you to focus 90% of your
                    energy on the actual product features rather than managing infrastructure. Cloudflare Workers +
                    Resend provided the perfect minimal-overhead stack.
                </div>

                <h3>5. Mastering the Workflow: Read, Redirect, and Plan</h3>

                <p>The day-to-day development process was a fascinating experiment in human-AI collaboration. My
                    workflow evolved through several distinct stages:</p>

                <ul>
                    <li><strong>The "Watch and Learn" Phase</strong>: Initially, I’d give broad instructions like
                        "create email + OTP-based authentication" and simply watch the AI work. Even though I wasn't a
                        Dart or JS expert, my 7+ years of experience in Python allowed me to <em>read</em> the code
                        effectively.</li>
                    <li><strong>The "Active Redirection" Phase</strong>: As with any collaborator, AI sometimes goes off
                        on a tangent. I learned early on that I couldn't just be a passive observer. I had to stop the
                        process, provide feedback, and redirect the AI back to the intended path.</li>
                    <li><strong>The Breakthrough: Plan Mode</strong>: The biggest shift in productivity came when I
                        discovered <strong>Plan Mode</strong>. Instead of having the AI jump straight into coding, I
                        started asking it to outline its approach first. We would refine the plan together until I was
                        satisfied, and <em>then</em> let it execute.</li>
                </ul>

                <div class="takeaway">
                    <strong>The takeaway:</strong> Your value as an experienced developer in "vibe-coding" isn't
                    necessarily in writing every line, but in your ability to <strong>read, review, and
                        strategize</strong>. Moving from immediate execution to a "Plan -> Refine -> Execute" cycle is
                    the secret to high-velocity, high-quality development.
                </div>

                <h3>6. The Automation Secret: The Power of the Makefile</h3>

                <p>One of the most impactful decisions I made during development was asking GPT-5 to help me create a
                    comprehensive <strong>Makefile</strong>. This wasn't just for compiling; it became the central
                    nervous system of my development cycle.</p>

                <ul>
                    <li><strong><code>make debug</code></strong>: This single command started the backend server
                        locally, built the app, and launched it with all local environments configured.</li>
                    <li><strong>The Flutter Advantage</strong>: Flutter was a game-changer here. For local debugging, I
                        would run the app as a <strong>macOS desktop app</strong> rather than an iOS simulator. This
                        made the feedback loop incredibly fast.</li>
                    <li><strong>Targeted Commands</strong>: <code>make android</code> handled the build and deployment
                        directly to my personal device; <code>make deploy</code> automated the backend;
                        <code>make screenshots</code> generated marketing materials; and <code>make publish</code>
                        handled the App Store draft process.</li>
                </ul>

                <div class="takeaway">
                    <strong>The takeaway:</strong> Don't just vibe-code the app; vibe-code your tools. Whether it's a
                    Makefile or NPM scripts, automating the repetitive tasks accelerates your velocity and keeps you in
                    the "flow state."
                </div>

                <h3>7. The Final Hurdle: Navigating Apple's App Review</h3>

                <p>While the coding was fast, the final step—getting into the App Store—had its own set of challenges.
                    It wasn't that the review itself was impossible to pass, but the logistics were surprisingly
                    complex.</p>

                <p>The biggest hurdle was understanding the dance between the build and the configuration of
                    <strong>In-App Purchases (IAP)</strong>. Figuring out how to submit the first IAP alongside the
                    initial build for review was a bit of a puzzle. It required a fair amount of trial and error,
                    cross-referencing documentation, and patience.</p>

                <p>But eventually, the notification came through: <strong>Approved.</strong></p>

                <p>Seeing my own iOS app live on the Apple App Store was truly a "dream come true" moment. After years
                    of frustration, I could finally send a link to friends and colleagues and say, "I built this."</p>

                <div class="takeaway">
                    <strong>The takeaway:</strong> The last 5% of the project—the distribution and compliance—can feel
                    like a different world compared to coding. Don't let the bureaucratic hurdles of the App Store
                    discourage you; the feeling of seeing your app live is worth every trial and error.
                </div>

                <h3>8. The Reality Check: Manual Testing is Non-Negotiable</h3>

                <p>Vibe-coding is remarkably fast, but that speed comes with a hidden risk: opacity. When you're
                    building in a new language or framework, many of the underlying nuances are invisible to you. This
                    makes rigorous <strong>manual testing</strong> an absolute necessity.</p>

                <p>I learned this the hard way by accidentally shipping a test build to the App Store—twice. Because I
                    couldn't easily verify every detail of the final generated build, small configuration errors slipped
                    through.</p>

                <p>You don't need to know every line of the framework, but you <strong>must</strong> ensure the final
                    build passes sanity checks, the happy path, and critical edge cases.</p>

                <div class="takeaway">
                    <strong>The takeaway:</strong> Don't let the AI's confidence fool you. You are the final quality
                    gate. While even huge organizations ship bugs, your goal should be to bridge the knowledge gap with
                    a robust manual verification process.
                </div>

                <h3>9. Beyond "AI Slop": The Developer as Creative Director</h3>

                <p>There is a valid concern in the industry about "shipping slop"—low-quality, AI-generated junk. I
                    sympathize with this; I never want to ship bugs or subpar experiences. However, my goal is to solve
                    real problems.</p>

                <p>Working with AI during this project felt less like using a code generator and more like having access
                    to a team of mid-level engineers for every specialized task—frontend, backend, automation, and even
                    App Store optimization. </p>

                <p>Ultimately, I am responsible for every line of code that gets shipped. The AI provides the labor, but
                    I provide the <strong>vision</strong>. It is this human-driven guidance, creativity, and commitment
                    to solving a problem that serves as the ultimate antidote to AI slop.</p>

                <div class="takeaway">
                    <strong>The takeaway:</strong> AI isn't a replacement for the developer; it's an amplifier for the
                    developer's vision. Your unique value lies in your ability to guide, refine, and take responsibility
                    for the final solution.
                </div>

                <h2>Conclusion</h2>

                <p>The journey from a "backend-only" developer to a published iOS app creator was made possible by the
                    bridge that vibe-coding provides. It's not just about writing code faster; it's about removing the
                    barriers that keep ideas trapped in our heads.</p>

                <p>I have always wanted to do more than just write code—I wanted to write fiction, create games, build
                    apps, and share ideas through creative storytelling. For a long time, these fields felt closed off
                    to anyone who hadn't spent years specializing in them. AI has changed that, making it possible for
                    anyone with a vision to build and create across disciplines.</p>

                <p>However, this democratization comes with a caveat. I still believe a writer with deep, lifelong
                    expertise is far superior to someone using AI to generate a story. In the same way, an experienced
                    software engineer can spot subtle architectural flaws in AI-generated code that an average user
                    might miss. As a society, our collective eye for "slop" will sharpen, and we will learn to value the
                    depth that only human expertise brings to the table.</p>

                <p>There are many problems still to be solved as we head into this future. But for now, if you've been
                    sitting on an idea because you don't "know the stack," let this be your sign. Pick a problem you
                    care about, choose your AI collaborator, and start vibing. </p>

                <p>The world is waiting for your story, your app, and your vision.</p>

                <div class="project-card">
                    <h3>Featured Project: XTranslate</h3>
                    <p>The project referenced in this post is <strong>XTranslate</strong>, an app that provides
                        real-time voice translation between Japanese and many other languages. It is specifically
                        designed to offer a seamless interpreter experience for tourists, foreigners living in Japan,
                        and Japanese people who frequently interact with international visitors.</p>
                    <a href="https://xtranslate.nauman.im/" target="_blank">Download XTranslate</a>
                </div>
            </article>
        </div>

        <footer>
            <p>&copy; 2025 Nauman Mustafa. All rights reserved.</p>
        </footer>
    </div>

    <script src="/lib/shared.js"></script>
    <script>
        // Adjust ruler lines opacity based on theme
        const themeToggle = document.getElementById('theme-toggle');
        const updateRulerOpacity = () => {
            const lines = document.querySelector('.paper-lines');
            if (document.documentElement.getAttribute('data-theme') === 'dark') {
                lines.style.opacity = '0.3';
            } else {
                lines.style.opacity = '0.6';
            }
        };

        // Listen for theme toggle events (assuming shared.js handles the attribute change)
        themeToggle.addEventListener('click', () => {
            // Wait for shared.js to execute or trigger it here if needed
            setTimeout(updateRulerOpacity, 50);
        });

        updateRulerOpacity();
    </script>
</body>

</html>